"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactTinyVirtualList = _interopRequireDefault(require("react-tiny-virtual-list"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _layers = require("../../layers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var TableVirtualBody =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2["default"])(TableVirtualBody, _PureComponent);
  (0, _createClass2["default"])(TableVirtualBody, null, [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (props.height !== state.calculatedHeight) {
        return {
          isIntegerHeight: Number.isInteger(props.height)
        };
      } // Return null to indicate no change to state.


      return null;
    }
  }]);

  function TableVirtualBody(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, TableVirtualBody);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(TableVirtualBody).call(this, props));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
      isIntegerHeight: false,
      calculatedHeight: 0
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "initializeHelpers", function () {
      _this.autoHeights = [];
      _this.autoHeightRefs = [];
      _this.averageAutoHeight = _this.props.defaultHeight;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "processAutoHeights", function () {
      var isUpdated = false; // This will determine the averageAutoHeight.

      var total = 0;
      var totalAmount = 0; // Loop through all of the refs that have height="auto".

      _this.autoHeightRefs.forEach(function (ref, index) {
        // If the height is already calculated, skip it,
        // but calculate the height for the total.
        if (_this.autoHeights[index]) {
          total += _this.autoHeights[index];
          totalAmount += 1;
          return;
        } // Make sure the ref has a child


        if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {
          var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.

          total += height;
          totalAmount += 1; // Cache the height.

          _this.autoHeights[index] = height; // Set the update flag to true.

          isUpdated = true;
        }
      }); // Save the average height.


      _this.averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.
      // Call forceUpdate to make sure the virtual list renders again.

      if (isUpdated) _this.forceUpdate();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onRef", function (ref) {
      _this.paneRef = ref;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onVirtualHelperRef", function (index, ref) {
      _this.autoHeightRefs[index] = ref;
      requestAnimationFrame(function () {
        _this.processAutoHeights();
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onResize", function () {
      _this.updateOnResize();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "updateOnResize", function () {
      _this.initializeHelpers(); // Simply return when we now the height of the pane is fixed.


      if (_this.state.isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.

      if (_this.paneRef) {
        var calculatedHeight = _this.paneRef.offsetHeight;

        if (calculatedHeight > 0) {
          // Save the calculated height which is needed for the VirtualList.
          _this.setState({
            calculatedHeight: calculatedHeight
          }); // Prevent updateOnResize being called recursively when there is a valid height.


          return;
        }
      } // When height is still 0 (or paneRef is not valid) try recursively until success.


      requestAnimationFrame(function () {
        _this.updateOnResize();
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getItemSize", function (children) {
      var _this$props = _this.props,
          allowAutoHeight = _this$props.allowAutoHeight,
          useAverageAutoHeightEstimation = _this$props.useAverageAutoHeightEstimation,
          defaultHeight = _this$props.defaultHeight; // Prefer to return a array of all heights.

      if (!allowAutoHeight) {
        return children.map(function (child) {
          if (!_react["default"].isValidElement(child)) return defaultHeight;
          var height = child.props.height;

          if (Number.isInteger(height)) {
            return height;
          }

          return defaultHeight;
        });
      } // If allowAutoHeight is true, return a function instead.


      var itemSizeFn = function itemSizeFn(index) {
        if (!_react["default"].isValidElement(children[index])) return defaultHeight;
        var height = children[index].props.height; // When the height is number simply, simply return it.

        if (Number.isInteger(height)) {
          return height;
        } // When allowAutoHeight is set and  the height is set to "auto"...


        if (allowAutoHeight && children[index].props.height === 'auto') {
          // ... and the height is calculated, return the calculated height.
          if (_this.autoHeights[index]) return _this.autoHeights[index]; // ... if the height is not yet calculated, return the averge

          if (useAverageAutoHeightEstimation) return _this.averageAutoHeight;
        } // Return the default height.


        return defaultHeight;
      };

      return itemSizeFn;
    });

    _this.initializeHelpers(); // Add a onResize.


    _this.onResize = (0, _lodash["default"])(_this.onResize, 200);
    return _this;
  }

  (0, _createClass2["default"])(TableVirtualBody, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Call this to initialize and set
      this.updateOnResize();
      window.addEventListener('resize', this.onResize, false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          inputChildren = _this$props2.children,
          paneHeight = _this$props2.height,
          defaultHeight = _this$props2.defaultHeight,
          allowAutoHeight = _this$props2.allowAutoHeight,
          overscanCount = _this$props2.overscanCount,
          estimatedItemSize = _this$props2.estimatedItemSize,
          useAverageAutoHeightEstimation = _this$props2.useAverageAutoHeightEstimation,
          scrollToIndex = _this$props2.scrollToIndex,
          scrollOffset = _this$props2.scrollOffset,
          scrollToAlignment = _this$props2.scrollToAlignment,
          onScroll = _this$props2.onScroll,
          props = (0, _objectWithoutProperties2["default"])(_this$props2, ["children", "height", "defaultHeight", "allowAutoHeight", "overscanCount", "estimatedItemSize", "useAverageAutoHeightEstimation", "scrollToIndex", "scrollOffset", "scrollToAlignment", "onScroll"]); // Children always needs to be an array.

      var children = Array.isArray(inputChildren) ? inputChildren : _react["default"].Children.toArray(inputChildren);
      var itemSize = this.getItemSize(children); // VirtualList needs a fixed height.

      var _this$state = this.state,
          calculatedHeight = _this$state.calculatedHeight,
          isIntegerHeight = _this$state.isIntegerHeight;
      return _react["default"].createElement(_layers.Pane, (0, _extends2["default"])({
        "data-evergreen-table-body": true,
        innerRef: this.onRef,
        height: paneHeight,
        flex: "1",
        overflow: "hidden"
      }, props), _react["default"].createElement(_reactTinyVirtualList["default"], {
        height: isIntegerHeight ? paneHeight : calculatedHeight,
        width: "100%",
        estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? this.averageAutoHeight : estimatedItemSize || null,
        itemSize: itemSize,
        overscanCount: overscanCount,
        itemCount: _react["default"].Children.count(children),
        scrollToIndex: scrollToIndex,
        scrollOffset: scrollOffset,
        scrollToAlignment: scrollToAlignment,
        onScroll: onScroll,
        renderItem: function renderItem(_ref) {
          var index = _ref.index,
              style = _ref.style;
          var child = children[index];
          var key = child.key || index;
          var props = {
            key: key,
            style: style
          }; // If some children are strings by accident, support this gracefully.

          if (!_react["default"].isValidElement(child)) {
            if (typeof child === 'string') {
              return _react["default"].createElement("div", props, child);
            }

            return _react["default"].createElement("div", props, "\xA0");
          } // When allowing height="auto" for rows, and a auto height item is
          // rendered for the first time...


          if (allowAutoHeight && _react["default"].isValidElement(child) && child.props.height === 'auto' && // ... and only when the height is not already been calculated.
          !_this2.autoHeights[index]) {
            // ... render the item in a helper div, the ref is used to calculate
            // the height of its children.
            return _react["default"].createElement("div", (0, _extends2["default"])({
              ref: function ref(_ref2) {
                return _this2.onVirtualHelperRef(index, _ref2);
              },
              "data-virtual-index": index
            }, props, {
              style: _objectSpread({
                opacity: 0
              }, props.style)
            }), child);
          } // When allowAutoHeight is false, or when the height is known.
          // Simply render the item.


          return _react["default"].cloneElement(child, props);
        }
      }));
    }
  }]);
  return TableVirtualBody;
}(_react.PureComponent);

exports["default"] = TableVirtualBody;
TableVirtualBody.displayName = "TableVirtualBody";
(0, _defineProperty2["default"])(TableVirtualBody, "propTypes", _objectSpread({}, _layers.Pane.propTypes, {
  /**
   * Children needs to be an array of a single node.
   */
  children: _propTypes["default"].oneOfType([_propTypes["default"].arrayOf(_propTypes["default"].node), _propTypes["default"].node]),

  /**
   * Default height of each row.
   * 48 is the default height of a TableRow.
   */
  defaultHeight: _propTypes["default"].number,

  /**
   * When true, support `height="auto"` on children being rendered.
   * This is somewhat of an expirmental feature.
   */
  allowAutoHeight: _propTypes["default"].bool,

  /**
   * The overscanCount property passed to react-tiny-virtual-list.
   */
  overscanCount: _propTypes["default"].number.isRequired,

  /**
   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.
   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.
   */
  estimatedItemSize: _propTypes["default"].number,

  /**
   * When allowAutoHeight is true and this prop is true, the estimated height
   * will be computed based on the average height of auto height rows.
   */
  useAverageAutoHeightEstimation: _propTypes["default"].bool,

  /**
   * The scrollToIndex property passed to react-tiny-virtual-list
   */
  scrollToIndex: _propTypes["default"].number,

  /**
   * The scrollOffset property passed to react-tiny-virtual-list
   */
  scrollOffset: _propTypes["default"].number,

  /**
   * The scrollToAlignment property passed to react-tiny-virtual-list
   */
  scrollToAlignment: _propTypes["default"].oneOf(['start', 'center', 'end', 'auto']),

  /**
   * The onScroll callback passed to react-tiny-virtual-list
   */
  onScroll: _propTypes["default"].func
}));
(0, _defineProperty2["default"])(TableVirtualBody, "defaultProps", {
  defaultHeight: 48,
  allowAutoHeight: false,
  overscanCount: 5,
  useAverageAutoHeightEstimation: true
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVWaXJ0dWFsQm9keS5qcyJdLCJuYW1lcyI6WyJUYWJsZVZpcnR1YWxCb2R5IiwicHJvcHMiLCJzdGF0ZSIsImhlaWdodCIsImNhbGN1bGF0ZWRIZWlnaHQiLCJpc0ludGVnZXJIZWlnaHQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJhdXRvSGVpZ2h0cyIsImF1dG9IZWlnaHRSZWZzIiwiYXZlcmFnZUF1dG9IZWlnaHQiLCJkZWZhdWx0SGVpZ2h0IiwiaXNVcGRhdGVkIiwidG90YWwiLCJ0b3RhbEFtb3VudCIsImZvckVhY2giLCJyZWYiLCJpbmRleCIsImNoaWxkTm9kZXMiLCJvZmZzZXRIZWlnaHQiLCJmb3JjZVVwZGF0ZSIsInBhbmVSZWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwcm9jZXNzQXV0b0hlaWdodHMiLCJ1cGRhdGVPblJlc2l6ZSIsImluaXRpYWxpemVIZWxwZXJzIiwic2V0U3RhdGUiLCJjaGlsZHJlbiIsImFsbG93QXV0b0hlaWdodCIsInVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbiIsIm1hcCIsImNoaWxkIiwiUmVhY3QiLCJpc1ZhbGlkRWxlbWVudCIsIml0ZW1TaXplRm4iLCJvblJlc2l6ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5wdXRDaGlsZHJlbiIsInBhbmVIZWlnaHQiLCJvdmVyc2NhbkNvdW50IiwiZXN0aW1hdGVkSXRlbVNpemUiLCJzY3JvbGxUb0luZGV4Iiwic2Nyb2xsT2Zmc2V0Iiwic2Nyb2xsVG9BbGlnbm1lbnQiLCJvblNjcm9sbCIsIkFycmF5IiwiaXNBcnJheSIsIkNoaWxkcmVuIiwidG9BcnJheSIsIml0ZW1TaXplIiwiZ2V0SXRlbVNpemUiLCJvblJlZiIsImNvdW50Iiwic3R5bGUiLCJrZXkiLCJvblZpcnR1YWxIZWxwZXJSZWYiLCJvcGFjaXR5IiwiY2xvbmVFbGVtZW50IiwiUHVyZUNvbXBvbmVudCIsIlBhbmUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJvbmVPZlR5cGUiLCJhcnJheU9mIiwibm9kZSIsIm51bWJlciIsImJvb2wiLCJpc1JlcXVpcmVkIiwib25lT2YiLCJmdW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7SUFFcUJBLGdCOzs7Ozs7NkNBMEVhQyxLLEVBQU9DLEssRUFBTztBQUM1QyxVQUFJRCxLQUFLLENBQUNFLE1BQU4sS0FBaUJELEtBQUssQ0FBQ0UsZ0JBQTNCLEVBQTZDO0FBQzNDLGVBQU87QUFDTEMsVUFBQUEsZUFBZSxFQUFFQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJOLEtBQUssQ0FBQ0UsTUFBdkI7QUFEWixTQUFQO0FBR0QsT0FMMkMsQ0FPNUM7OztBQUNBLGFBQU8sSUFBUDtBQUNEOzs7QUFFRCw0QkFBWUYsS0FBWixFQUFtQjtBQUFBOztBQUFBO0FBQ2pCLDRIQUFNQSxLQUFOO0FBRGlCLDhGQWhCWDtBQUNOSSxNQUFBQSxlQUFlLEVBQUUsS0FEWDtBQUVORCxNQUFBQSxnQkFBZ0IsRUFBRTtBQUZaLEtBZ0JXO0FBQUEsMEdBbUJDLFlBQU07QUFDeEIsWUFBS0ksV0FBTCxHQUFtQixFQUFuQjtBQUNBLFlBQUtDLGNBQUwsR0FBc0IsRUFBdEI7QUFDQSxZQUFLQyxpQkFBTCxHQUF5QixNQUFLVCxLQUFMLENBQVdVLGFBQXBDO0FBQ0QsS0F2QmtCO0FBQUEsMkdBNkJFLFlBQU07QUFDekIsVUFBSUMsU0FBUyxHQUFHLEtBQWhCLENBRHlCLENBR3pCOztBQUNBLFVBQUlDLEtBQUssR0FBRyxDQUFaO0FBQ0EsVUFBSUMsV0FBVyxHQUFHLENBQWxCLENBTHlCLENBT3pCOztBQUNBLFlBQUtMLGNBQUwsQ0FBb0JNLE9BQXBCLENBQTRCLFVBQUNDLEdBQUQsRUFBTUMsS0FBTixFQUFnQjtBQUMxQztBQUNBO0FBQ0EsWUFBSSxNQUFLVCxXQUFMLENBQWlCUyxLQUFq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RUFBRWtCLHNCQUFVTyxLQUFWLENBQWdCLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsS0FBcEIsRUFBMkIsTUFBM0IsQ0FBaEIsQzs7QUFDbkI7OztBQUdBeEIsRUFBQUEsUUFBUSxFQUFFaUIsc0JBQVVROztpQ0EzREh2RSxnQixrQkE4REc7QUFDcEJXLEVBQUFBLGFBQWEsRUFBRSxFQURLO0FBRXBCaUIsRUFBQUEsZUFBZSxFQUFFLEtBRkc7QUFHcEJhLEVBQUFBLGFBQWEsRUFBRSxDQUhLO0FBSXBCWixFQUFBQSw4QkFBOEIsRUFBRTtBQUpaLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gJ3JlYWN0LXRpbnktdmlydHVhbC1saXN0J1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYmxlVmlydHVhbEJvZHkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21wb3NlcyB0aGUgUGFuZSBjb21wb25lbnQgYXMgdGhlIGJhc2UuXG4gICAgICovXG4gICAgLi4uUGFuZS5wcm9wVHlwZXMsXG5cbiAgICAvKipcbiAgICAgKiBDaGlsZHJlbiBuZWVkcyB0byBiZSBhbiBhcnJheSBvZiBhIHNpbmdsZSBub2RlLlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5ub2RlKSxcbiAgICAgIFByb3BUeXBlcy5ub2RlXG4gICAgXSksXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGhlaWdodCBvZiBlYWNoIHJvdy5cbiAgICAgKiA0OCBpcyB0aGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBUYWJsZVJvdy5cbiAgICAgKi9cbiAgICBkZWZhdWx0SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBzdXBwb3J0IGBoZWlnaHQ9XCJhdXRvXCJgIG9uIGNoaWxkcmVuIGJlaW5nIHJlbmRlcmVkLlxuICAgICAqIFRoaXMgaXMgc29tZXdoYXQgb2YgYW4gZXhwaXJtZW50YWwgZmVhdHVyZS5cbiAgICAgKi9cbiAgICBhbGxvd0F1dG9IZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG92ZXJzY2FuQ291bnQgcHJvcGVydHkgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0LlxuICAgICAqL1xuICAgIG92ZXJzY2FuQ291bnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFzc2VkLCB0aGlzIGlzIHVzZWQgYXMgdGhlIGBlc3RpbWF0ZWRJdGVtU2l6ZWAgaW4gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3QuXG4gICAgICogT25seSB3aGVuIGBhbGxvd0F1dG9IZWlnaHRgIGFuZGB1c2VBdmVyYWdlQXV0b0hlaWdodEVzdGltYXRpb25gIGFyZSBmYWxzZS5cbiAgICAgKi9cbiAgICBlc3RpbWF0ZWRJdGVtU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHRydWUgYW5kIHRoaXMgcHJvcCBpcyB0cnVlLCB0aGUgZXN0aW1hdGVkIGhlaWdodFxuICAgICAqIHdpbGwgYmUgY29tcHV0ZWQgYmFzZWQgb24gdGhlIGF2ZXJhZ2UgaGVpZ2h0IG9mIGF1dG8gaGVpZ2h0IHJvd3MuXG4gICAgICovXG4gICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY3JvbGxUb0luZGV4IHByb3BlcnR5IHBhc3NlZCB0byByZWFjdC10aW55LXZpcnR1YWwtbGlzdFxuICAgICAqL1xuICAgIHNjcm9sbFRvSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgLyoqXG4gICAgICogVGhlIHNjcm9sbE9mZnNldCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3RcbiAgICAgKi9cbiAgICBzY3JvbGxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgLyoqXG4gICAgICogVGhlIHNjcm9sbFRvQWxpZ25tZW50IHByb3BlcnR5IHBhc3NlZCB0byByZWFjdC10aW55LXZpcnR1YWwtbGlzdFxuICAgICAqL1xuICAgIHNjcm9sbFRvQWxpZ25tZW50OiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2F1dG8nXSksXG4gICAgLyoqXG4gICAgICogVGhlIG9uU2Nyb2xsIGNhbGxiYWNrIHBhc3NlZCB0byByZWFjdC10aW55LXZpcnR1YWwtbGlzdFxuICAgICAqL1xuICAgIG9uU2Nyb2xsOiBQcm9wVHlwZXMuZnVuY1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkZWZhdWx0SGVpZ2h0OiA0OCxcbiAgICBhbGxvd0F1dG9IZWlnaHQ6IGZhbHNlLFxuICAgIG92ZXJzY2FuQ291bnQ6IDUsXG4gICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uOiB0cnVlXG4gIH1cblxuICBzdGF0ZSA9IHtcbiAgICBpc0ludGVnZXJIZWlnaHQ6IGZhbHNlLFxuICAgIGNhbGN1bGF0ZWRIZWlnaHQ6IDBcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmhlaWdodCAhPT0gc3RhdGUuY2FsY3VsYXRlZEhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNJbnRlZ2VySGVpZ2h0OiBOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmhlaWdodClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG5cbiAgICB0aGlzLmluaXRpYWxpemVIZWxwZXJzKClcblxuICAgIC8vIEFkZCBhIG9uUmVzaXplLlxuICAgIHRoaXMub25SZXNpemUgPSBkZWJvdW5jZSh0aGlzLm9uUmVzaXplLCAyMDApXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBDYWxsIHRoaXMgdG8gaW5pdGlhbGl6ZSBhbmQgc2V0XG4gICAgdGhpcy51cGRhdGVPblJlc2l6ZSgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUsIGZhbHNlKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpXG4gIH1cblxuICBpbml0aWFsaXplSGVscGVycyA9ICgpID0+IHtcbiAgICB0aGlzLmF1dG9IZWlnaHRzID0gW11cbiAgICB0aGlzLmF1dG9IZWlnaHRSZWZzID0gW11cbiAgICB0aGlzLmF2ZXJhZ2VBdXRvSGVpZ2h0ID0gdGhpcy5wcm9wcy5kZWZhdWx0SGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHByb2Nlc3MgYWxsIGl0ZW1zIHRoYXQgaGF2ZSBoZWlnaHQ9XCJhdXRvXCIgc2V0LlxuICAgKiBJdCB3aWxsIGxvb3AgdGhyb3VnaCBhbGwgcmVmcyBhbmQgZ2V0IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0LlxuICAgKi9cbiAgcHJvY2Vzc0F1dG9IZWlnaHRzID0gKCkgPT4ge1xuICAgIGxldCBpc1VwZGF0ZWQgPSBmYWxzZVxuXG4gICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgYXZlcmFnZUF1dG9IZWlnaHQuXG4gICAgbGV0IHRvdGFsID0gMFxuICAgIGxldCB0b3RhbEFtb3VudCA9IDBcblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIHJlZnMgdGhhdCBoYXZlIGhlaWdodD1cImF1dG9cIi5cbiAgICB0aGlzLmF1dG9IZWlnaHRSZWZzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcbiAgICAgIC8vIElmIHRoZSBoZWlnaHQgaXMgYWxyZWFkeSBjYWxjdWxhdGVkLCBza2lwIGl0LFxuICAgICAgLy8gYnV0IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZvciB0aGUgdG90YWwuXG4gICAgICBpZiAodGhpcy5hdXRvSGVpZ2h0c1tpbmRleF0pIHtcbiAgICAgICAgdG90YWwgKz0gdGhpcy5hdXRvSGVpZ2h0c1tpbmRleF1cbiAgICAgICAgdG90YWxBbW91bnQgKz0gMVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZWYgaGFzIGEgY2hpbGRcbiAgICAgIGlmIChcbiAgICAgICAgcmVmICYmXG4gICAgICAgIHJlZi5jaGlsZE5vZGVzICYmXG4gICAgICAgIHJlZi5jaGlsZE5vZGVzWzBdICYmXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIocmVmLmNoaWxkTm9kZXNbMF0ub2Zmc2V0SGVpZ2h0KVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHJlZi5jaGlsZE5vZGVzWzBdLm9mZnNldEhlaWdodFxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgdG90YWwgdG8gY2FsY3VsYXRlIHRoZSBhdmVyYWdlQXV0b0hlaWdodC5cbiAgICAgICAgdG90YWwgKz0gaGVpZ2h0XG4gICAgICAgIHRvdGFsQW1vdW50ICs9IDFcblxuICAgICAgICAvLyBDYWNoZSB0aGUgaGVpZ2h0LlxuICAgICAgICB0aGlzLmF1dG9IZWlnaHRzW2luZGV4XSA9IGhlaWdodFxuXG4gICAgICAgIC8vIFNldCB0aGUgdXBkYXRlIGZsYWcgdG8gdHJ1ZS5cbiAgICAgICAgaXNVcGRhdGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBTYXZlIHRoZSBhdmVyYWdlIGhlaWdodC5cbiAgICB0aGlzLmF2ZXJhZ2VBdXRvSGVpZ2h0ID0gdG90YWwgLyB0b3RhbEFtb3VudFxuXG4gICAgLy8gVGhlcmUgYXJlIHNvbWUgbmV3IGhlaWdodHMgZGV0ZWN0ZWQgdGhhdCBoYWQgcHJldmlvdXNseSBub3QgYmVlbiBjYWxjdWxhdGVkLlxuICAgIC8vIENhbGwgZm9yY2VVcGRhdGUgdG8gbWFrZSBzdXJlIHRoZSB2aXJ0dWFsIGxpc3QgcmVuZGVycyBhZ2Fpbi5cbiAgICBpZiAoaXNVcGRhdGVkKSB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIG9uUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnBhbmVSZWYgPSByZWZcbiAgfVxuXG4gIG9uVmlydHVhbEhlbHBlclJlZiA9IChpbmRleCwgcmVmKSA9PiB7XG4gICAgdGhpcy5hdXRvSGVpZ2h0UmVmc1tpbmRleF0gPSByZWZcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NBdXRvSGVpZ2h0cygpXG4gICAgfSlcbiAgfVxuXG4gIG9uUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMudXBkYXRlT25SZXNpemUoKVxuICB9XG5cbiAgdXBkYXRlT25SZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy5pbml0aWFsaXplSGVscGVycygpXG5cbiAgICAvLyBTaW1wbHkgcmV0dXJuIHdoZW4gd2Ugbm93IHRoZSBoZWlnaHQgb2YgdGhlIHBhbmUgaXMgZml4ZWQuXG4gICAgaWYgKHRoaXMuc3RhdGUuaXNJbnRlZ2VySGVpZ2h0KSByZXR1cm5cblxuICAgIC8vIFJldHVybiBpZiB3ZSBhcmUgaW4gYSB3ZWlyZCBlZGdlIGNhc2UgaW4gd2hpY2ggdGhlIHJlZiBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgaWYgKHRoaXMucGFuZVJlZikge1xuICAgICAgY29uc3QgY2FsY3VsYXRlZEhlaWdodCA9IHRoaXMucGFuZVJlZi5vZmZzZXRIZWlnaHRcblxuICAgICAgaWYgKGNhbGN1bGF0ZWRIZWlnaHQgPiAwKSB7XG4gICAgICAgIC8vIFNhdmUgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IHdoaWNoIGlzIG5lZWRlZCBmb3IgdGhlIFZpcnR1YWxMaXN0LlxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGVPblJlc2l6ZSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkgd2hlbiB0aGVyZSBpcyBhIHZhbGlkIGhlaWdodC5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBoZWlnaHQgaXMgc3RpbGwgMCAob3IgcGFuZVJlZiBpcyBub3QgdmFsaWQpIHRyeSByZWN1cnNpdmVseSB1bnRpbCBzdWNjZXNzLlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU9uUmVzaXplKClcbiAgICB9KVxuICB9XG5cbiAgZ2V0SXRlbVNpemUgPSBjaGlsZHJlbiA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dBdXRvSGVpZ2h0LFxuICAgICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uLFxuICAgICAgZGVmYXVsdEhlaWdodFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICAvLyBQcmVmZXIgdG8gcmV0dXJuIGEgYXJyYXkgb2YgYWxsIGhlaWdodHMuXG4gICAgaWYgKCFhbGxvd0F1dG9IZWlnaHQpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkgcmV0dXJuIGRlZmF1bHRIZWlnaHRcbiAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNoaWxkLnByb3BzXG5cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiBoZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIGFsbG93QXV0b0hlaWdodCBpcyB0cnVlLCByZXR1cm4gYSBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgIGNvbnN0IGl0ZW1TaXplRm4gPSBpbmRleCA9PiB7XG4gICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuW2luZGV4XSkpIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICBjb25zdCB7IGhlaWdodCB9ID0gY2hpbGRyZW5baW5kZXhdLnByb3BzXG5cbiAgICAgIC8vIFdoZW4gdGhlIGhlaWdodCBpcyBudW1iZXIgc2ltcGx5LCBzaW1wbHkgcmV0dXJuIGl0LlxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHNldCBhbmQgIHRoZSBoZWlnaHQgaXMgc2V0IHRvIFwiYXV0b1wiLi4uXG4gICAgICBpZiAoYWxsb3dBdXRvSGVpZ2h0ICYmIGNoaWxkcmVuW2luZGV4XS5wcm9wcy5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAvLyAuLi4gYW5kIHRoZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCwgcmV0dXJuIHRoZSBjYWxjdWxhdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKHRoaXMuYXV0b0hlaWdodHNbaW5kZXhdKSByZXR1cm4gdGhpcy5hdXRvSGVpZ2h0c1tpbmRleF1cblxuICAgICAgICAvLyAuLi4gaWYgdGhlIGhlaWdodCBpcyBub3QgeWV0IGNhbGN1bGF0ZWQsIHJldHVybiB0aGUgYXZlcmdlXG4gICAgICAgIGlmICh1c2VBdmVyYWdlQXV0b0hlaWdodEVzdGltYXRpb24pIHJldHVybiB0aGlzLmF2ZXJhZ2VBdXRvSGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgZGVmYXVsdCBoZWlnaHQuXG4gICAgICByZXR1cm4gZGVmYXVsdEhlaWdodFxuICAgIH1cblxuICAgIHJldHVybiBpdGVtU2l6ZUZuXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW46IGlucHV0Q2hpbGRyZW4sXG4gICAgICBoZWlnaHQ6IHBhbmVIZWlnaHQsXG4gICAgICBkZWZhdWx0SGVpZ2h0LFxuICAgICAgYWxsb3dBdXRvSGVpZ2h0LFxuICAgICAgb3ZlcnNjYW5Db3VudCxcbiAgICAgIGVzdGltYXRlZEl0ZW1TaXplLFxuICAgICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uLFxuICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgIHNjcm9sbFRvQWxpZ25tZW50LFxuICAgICAgb25TY3JvbGwsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICAvLyBDaGlsZHJlbiBhbHdheXMgbmVlZHMgdG8gYmUgYW4gYXJyYXkuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KGlucHV0Q2hpbGRyZW4pXG4gICAgICA/IGlucHV0Q2hpbGRyZW5cbiAgICAgIDogUmVhY3QuQ2hpbGRyZW4udG9BcnJheShpbnB1dENoaWxkcmVuKVxuXG4gICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLmdldEl0ZW1TaXplKGNoaWxkcmVuKVxuXG4gICAgLy8gVmlydHVhbExpc3QgbmVlZHMgYSBmaXhlZCBoZWlnaHQuXG4gICAgY29uc3QgeyBjYWxjdWxhdGVkSGVpZ2h0LCBpc0ludGVnZXJIZWlnaHQgfSA9IHRoaXMuc3RhdGVcblxuICAgIHJldHVybiAoXG4gICAgICA8UGFuZVxuICAgICAgICBkYXRhLWV2ZXJncmVlbi10YWJsZS1ib2R5XG4gICAgICAgIGlubmVyUmVmPXt0aGlzLm9uUmVmfVxuICAgICAgICBoZWlnaHQ9e3BhbmVIZWlnaHR9XG4gICAgICAgIGZsZXg9XCIxXCJcbiAgICAgICAgb3ZlcmZsb3c9XCJoaWRkZW5cIlxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIDxWaXJ0dWFsTGlzdFxuICAgICAgICAgIGhlaWdodD17aXNJbnRlZ2VySGVpZ2h0ID8gcGFuZUhlaWdodCA6IGNhbGN1bGF0ZWRIZWlnaHR9XG4gICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICBlc3RpbWF0ZWRJdGVtU2l6ZT17XG4gICAgICAgICAgICBhbGxvd0F1dG9IZWlnaHQgJiYgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uXG4gICAgICAgICAgICAgID8gdGhpcy5hdmVyYWdlQXV0b0hlaWdodFxuICAgICAgICAgICAgICA6IGVzdGltYXRlZEl0ZW1TaXplIHx8IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbVNpemU9e2l0ZW1TaXplfVxuICAgICAgICAgIG92ZXJzY2FuQ291bnQ9e292ZXJzY2FuQ291bnR9XG4gICAgICAgICAgaXRlbUNvdW50PXtSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbil9XG4gICAgICAgICAgc2Nyb2xsVG9JbmRleD17c2Nyb2xsVG9JbmRleH1cbiAgICAgICAgICBzY3JvbGxPZmZzZXQ9e3Njcm9sbE9mZnNldH1cbiAgICAgICAgICBzY3JvbGxUb0FsaWdubWVudD17c2Nyb2xsVG9BbGlnbm1lbnR9XG4gICAgICAgICAgb25TY3JvbGw9e29uU2Nyb2xsfVxuICAgICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5IHx8IGluZGV4XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBzdHlsZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzb21lIGNoaWxkcmVuIGFyZSBzdHJpbmdzIGJ5IGFjY2lkZW50LCBzdXBwb3J0IHRoaXMgZ3JhY2VmdWxseS5cbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgey4uLnByb3BzfT57Y2hpbGR9PC9kaXY+XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gPGRpdiB7Li4ucHJvcHN9PiZuYnNwOzwvZGl2PlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIGFsbG93aW5nIGhlaWdodD1cImF1dG9cIiBmb3Igcm93cywgYW5kIGEgYXV0byBoZWlnaHQgaXRlbSBpc1xuICAgICAgICAgICAgLy8gcmVuZGVyZWQgZm9yIHRoZSBmaXJzdCB0aW1lLi4uXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGFsbG93QXV0b0hlaWdodCAmJlxuICAgICAgICAgICAgICBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkgJiZcbiAgICAgICAgICAgICAgY2hpbGQucHJvcHMuaGVpZ2h0ID09PSAnYXV0bycgJiZcbiAgICAgICAgICAgICAgLy8gLi4uIGFuZCBvbmx5IHdoZW4gdGhlIGhlaWdodCBpcyBub3QgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWQuXG4gICAgICAgICAgICAgICF0aGlzLmF1dG9IZWlnaHRzW2luZGV4XVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIC4uLiByZW5kZXIgdGhlIGl0ZW0gaW4gYSBoZWxwZXIgZGl2LCB0aGUgcmVmIGlzIHVzZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIHJlZj17cmVmID0+IHRoaXMub25WaXJ0dWFsSGVscGVyUmVmKGluZGV4LCByZWYpfVxuICAgICAgICAgICAgICAgICAgZGF0YS12aXJ0dWFsLWluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtjaGlsZH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIGFsbG93QXV0b0hlaWdodCBpcyBmYWxzZSwgb3Igd2hlbiB0aGUgaGVpZ2h0IGlzIGtub3duLlxuICAgICAgICAgICAgLy8gU2ltcGx5IHJlbmRlciB0aGUgaXRlbS5cbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHByb3BzKVxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICA8L1BhbmU+XG4gICAgKVxuICB9XG59XG4iXX0=