import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React from 'react';
import PropTypes from 'prop-types';
import debounce from 'lodash.debounce';
import { withTheme } from '../../theme';
import { SelectMenu } from '../../select-menu';
import { Icon } from '../../icon';
import TextTableCell from './TextTableCell';
import TableCell from './TableCell';
var MIN_SELECT_MENU_WIDTH = 240;

var SelectMenuCell =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(SelectMenuCell, _React$PureComponent);

  function SelectMenuCell(props) {
    var _this;

    _classCallCheck(this, SelectMenuCell);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SelectMenuCell).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "state", {
      targetWidth: MIN_SELECT_MENU_WIDTH,
      shouldClickToggle: false,
      isFocused: false
    });

    _defineProperty(_assertThisInitialized(_this), "onResize", function () {
      _this.updateOnResize();
    });

    _defineProperty(_assertThisInitialized(_this), "updateOnResize", function () {
      if (!_this.mainRef) return;
      var targetWidth = _this.mainRef.offsetWidth;

      _this.setState({
        targetWidth: Math.max(MIN_SELECT_MENU_WIDTH, targetWidth)
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onMainRef", function (getRef, ref) {
      _this.mainRef = ref;
      getRef(ref);
    });

    _defineProperty(_assertThisInitialized(_this), "onOverlayRef", function (ref) {
      _this.overlayRef = ref;
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (toggle, isShown, e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();

        if (!isShown && _this.props.isSelectable && !_this.props.disabled) {
          toggle();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleDoubleClick", function (toggle, isShown) {
      if (!isShown && _this.props.isSelectable && !_this.props.disabled) {
        toggle();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (toggle, isShown) {
      var shouldClickToggle = _this.state.shouldClickToggle;

      if (!shouldClickToggle && !isShown) {
        _this.setState({
          shouldClickToggle: true
        });

        return;
      }

      if (_this.props.isSelectable && !_this.props.disabled) {
        toggle();

        _this.setState({
          shouldClickToggle: true
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleFocus", function () {
      _this.setState({
        isFocused: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleBlur", function () {
      _this.setState({
        shouldClickToggle: false,
        isFocused: false
      });
    });

    _this.onResize = debounce(_this.onResize, 200);
    return _this;
  }

  _createClass(SelectMenuCell, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Call this to initialize and set
      this.updateOnResize();
      window.addEventListener('resize', this.onResize, false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          children = _this$props.children,
          theme = _this$props.theme,
          size = _this$props.size,
          selectMenuProps = _this$props.selectMenuProps,
          disabled = _this$props.disabled,
          placeholder = _this$props.placeholder,
          isSelectable = _this$props.isSelectable,
          _this$props$textProps = _this$props.textProps,
          textProps = _this$props$textProps === void 0 ? {} : _this$props$textProps,
          props = _objectWithoutProperties(_this$props, ["children", "theme", "size", "selectMenuProps", "disabled", "placeholder", "isSelectable", "textProps"]);

      var _this$state = this.state,
          targetWidth = _this$state.targetWidth,
          isFocused = _this$state.isFocused;
      var cursor = 'default';

      if (disabled) {
        cursor = 'not-allowed';
      } else if (isSelectable) {
        if (isFocused) {
          cursor = 'pointer';
        } else {
          cursor = 'default';
        }
      } else {
        cursor = 'text';
      }

      return React.createElement(SelectMenu, _extends({
        width: targetWidth
      }, selectMenuProps), function (_ref) {
        var toggle = _ref.toggle,
            getRef = _ref.getRef,
            isShown = _ref.isShown;
        return React.createElement(TextTableCell, _extends({
          innerRef: _this2.onMainRef.bind(null, getRef),
          onClick: _this2.handleClick.bind(null, toggle, isShown),
          onFocus: _this2.handleFocus.bind(null, toggle, isShown),
          onBlur: _this2.handleBlur,
          isSelectable: isSelectable && !disabled,
          rightView: isSelectable ? React.createElement(Icon, {
            icon: "caret-down",
            color: "muted"
          }) : null,
          "aria-haspopup": true,
          "aria-expanded": isShown,
          cursor: isShown ? 'pointer' : cursor,
          textProps: _objectSpread({
            size: size,
            opacity: disabled || !children && placeholder ? 0.5 : 1
          }, textProps),
          onKeyDown: _this2.handleKeyDown.bind(null, toggle, isShown),
          onDoubleClick: _this2.handleDoubleClick.bind(null, toggle, isShown)
        }, props), children ? children : placeholder);
      });
    }
  }]);

  return SelectMenuCell;
}(React.PureComponent);

SelectMenuCell.displayName = "SelectMenuCell";

_defineProperty(SelectMenuCell, "propTypes", _objectSpread({}, TableCell.propTypes, {
  /*
  * Makes the TableCell focusable.
  * Will add tabIndex={-1 || this.props.tabIndex}.
  */
  isSelectable: PropTypes.bool.isRequired,

  /**
   * When true, the cell can't be edited.
   */
  disabled: PropTypes.bool,

  /**
   * Optional placeholder when children is falsy.
   */
  placeholder: PropTypes.node,

  /**
   * The size used for the TextTableCell and Textarea.
   */
  size: PropTypes.oneOf([300, 400]).isRequired,
  selectMenuProps: PropTypes.object
}));

_defineProperty(SelectMenuCell, "defaultProps", {
  size: 300,
  isSelectable: true
});

export default withTheme(SelectMenuCell);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvU2VsZWN0TWVudUNlbGwuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJkZWJvdW5jZSIsIndpdGhUaGVtZSIsIlNlbGVjdE1lbnUiLCJJY29uIiwiVGV4dFRhYmxlQ2VsbCIsIlRhYmxlQ2VsbCIsIk1JTl9TRUxFQ1RfTUVOVV9XSURUSCIsIlNlbGVjdE1lbnVDZWxsIiwicHJvcHMiLCJ0YXJnZXRXaWR0aCIsInNob3VsZENsaWNrVG9nZ2xlIiwiaXNGb2N1c2VkIiwidXBkYXRlT25SZXNpemUiLCJtYWluUmVmIiwib2Zmc2V0V2lkdGgiLCJzZXRTdGF0ZSIsIk1hdGgiLCJtYXgiLCJnZXRSZWYiLCJyZWYiLCJvdmVybGF5UmVmIiwidG9nZ2xlIiwiaXNTaG93biIsImUiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImlzU2VsZWN0YWJsZSIsImRpc2FibGVkIiwic3RhdGUiLCJvblJlc2l6ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2hpbGRyZW4iLCJ0aGVtZSIsInNpemUiLCJzZWxlY3RNZW51UHJvcHMiLCJwbGFjZWhvbGRlciIsInRleHRQcm9wcyIsImN1cnNvciIsIm9uTWFpblJlZiIsImJpbmQiLCJoYW5kbGVDbGljayIsImhhbmRsZUZvY3VzIiwiaGFuZGxlQmx1ciIsIm9wYWNpdHkiLCJoYW5kbGVLZXlEb3duIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJQdXJlQ29tcG9uZW50IiwicHJvcFR5cGVzIiwiYm9vbCIsImlzUmVxdWlyZWQiLCJub2RlIiwib25lT2YiLCJvYmplY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxNQUFrQixPQUFsQjtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLGlCQUFyQjtBQUNBLFNBQVNDLFNBQVQs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RUFBOEJyQixNQUE5QixFQUFzQ0MsT0FBdEMsQ0FqQmI7QUFrQkUsVUFBQSxhQUFhLEVBQUUsTUFBSSxDQUFDMEIsaUJBQUwsQ0FBdUJOLElBQXZCLENBQTRCLElBQTVCLEVBQWtDckIsTUFBbEMsRUFBMENDLE9BQTFDO0FBbEJqQixXQW1CTWQsS0FuQk4sR0FxQkcwQixRQUFRLEdBQUdBLFFBQUgsR0FBY0ksV0FyQnpCLENBREY7QUF5QkQsT0EzQkgsQ0FERjtBQStCRDs7OztFQXhMMEJ4QyxLQUFLLENBQUNtRCxhOztBQUE3QjFDLGM7O2dCQUFBQSxjLGlDQUtDRixTQUFTLENBQUM2QyxTO0FBRWI7Ozs7QUFJQXZCLEVBQUFBLFlBQVksRUFBRTVCLFNBQVMsQ0FBQ29ELElBQVYsQ0FBZUMsVTs7QUFFN0I7OztBQUdBeEIsRUFBQUEsUUFBUSxFQUFFN0IsU0FBUyxDQUFDb0QsSTs7QUFFcEI7OztBQUdBYixFQUFBQSxXQUFXLEVBQUV2QyxTQUFTLENBQUNzRCxJOztBQUV2Qjs7O0FBR0FqQixFQUFBQSxJQUFJLEVBQUVyQyxTQUFTLENBQUN1RCxLQUFWLENBQWdCLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBaEIsRUFBNEJGLFU7QUFFbENmLEVBQUFBLGVBQWUsRUFBRXRDLFNBQVMsQ0FBQ3dEOzs7Z0JBNUJ6QmhELGMsa0JBK0JrQjtBQUNwQjZCLEVBQUFBLElBQUksRUFBRSxHQURjO0FBRXBCVCxFQUFBQSxZQUFZLEVBQUU7QUFGTSxDOztBQTRKeEIsZUFBZTFCLFNBQVMsQ0FBQ00sY0FBRCxDQUF4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2guZGVib3VuY2UnXG5pbXBvcnQgeyB3aXRoVGhlbWUgfSBmcm9tICcuLi8uLi90aGVtZSdcbmltcG9ydCB7IFNlbGVjdE1lbnUgfSBmcm9tICcuLi8uLi9zZWxlY3QtbWVudSdcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi8uLi9pY29uJ1xuaW1wb3J0IFRleHRUYWJsZUNlbGwgZnJvbSAnLi9UZXh0VGFibGVDZWxsJ1xuaW1wb3J0IFRhYmxlQ2VsbCBmcm9tICcuL1RhYmxlQ2VsbCdcblxuY29uc3QgTUlOX1NFTEVDVF9NRU5VX1dJRFRIID0gMjQwXG5cbmNsYXNzIFNlbGVjdE1lbnVDZWxsIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogQ29tcG9zZXMgdGhlIFRhYmxlQ2VsbCBjb21wb25lbnQgYXMgdGhlIGJhc2UuXG4gICAgICovXG4gICAgLi4uVGFibGVDZWxsLnByb3BUeXBlcyxcblxuICAgIC8qXG4gICAgKiBNYWtlcyB0aGUgVGFibGVDZWxsIGZvY3VzYWJsZS5cbiAgICAqIFdpbGwgYWRkIHRhYkluZGV4PXstMSB8fCB0aGlzLnByb3BzLnRhYkluZGV4fS5cbiAgICAqL1xuICAgIGlzU2VsZWN0YWJsZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGNlbGwgY2FuJ3QgYmUgZWRpdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIHBsYWNlaG9sZGVyIHdoZW4gY2hpbGRyZW4gaXMgZmFsc3kuXG4gICAgICovXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5ub2RlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgdXNlZCBmb3IgdGhlIFRleHRUYWJsZUNlbGwgYW5kIFRleHRhcmVhLlxuICAgICAqL1xuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbMzAwLCA0MDBdKS5pc1JlcXVpcmVkLFxuXG4gICAgc2VsZWN0TWVudVByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIHNpemU6IDMwMCxcbiAgICBpc1NlbGVjdGFibGU6IHRydWVcbiAgfVxuXG4gIHN0YXRlID0ge1xuICAgIHRhcmdldFdpZHRoOiBNSU5fU0VMRUNUX01FTlVfV0lEVEgsXG4gICAgc2hvdWxkQ2xpY2tUb2dnbGU6IGZhbHNlLFxuICAgIGlzRm9jdXNlZDogZmFsc2VcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5vblJlc2l6ZSA9IGRlYm91bmNlKHRoaXMub25SZXNpemUsIDIwMClcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIENhbGwgdGhpcyB0byBpbml0aWFsaXplIGFuZCBzZXRcbiAgICB0aGlzLnVwZGF0ZU9uUmVzaXplKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSwgZmFsc2UpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSlcbiAgfVxuXG4gIG9uUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMudXBkYXRlT25SZXNpemUoKVxuICB9XG5cbiAgdXBkYXRlT25SZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLm1haW5SZWYpIHJldHVyblxuICAgIGNvbnN0IHRhcmdldFdpZHRoID0gdGhpcy5tYWluUmVmLm9mZnNldFdpZHRoXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0YXJnZXRXaWR0aDogTWF0aC5tYXgoTUlOX1NFTEVDVF9NRU5VX1dJRFRILCB0YXJnZXRXaWR0aClcbiAgICB9KVxuICB9XG5cbiAgb25NYWluUmVmID0gKGdldFJlZiwgcmVmKSA9PiB7XG4gICAgdGhpcy5tYWluUmVmID0gcmVmXG4gICAgZ2V0UmVmKHJlZilcbiAgfVxuXG4gIG9uT3ZlcmxheVJlZiA9IHJlZiA9PiB7XG4gICAgdGhpcy5vdmVybGF5UmVmID0gcmVmXG4gIH1cblxuICBoYW5kbGVLZXlEb3duID0gKHRvZ2dsZSwgaXNTaG93biwgZSkgPT4ge1xuICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgIGlmICghaXNTaG93biAmJiB0aGlzLnByb3BzLmlzU2VsZWN0YWJsZSAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICB0b2dnbGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURvdWJsZUNsaWNrID0gKHRvZ2dsZSwgaXNTaG93bikgPT4ge1xuICAgIGlmICghaXNTaG93biAmJiB0aGlzLnByb3BzLmlzU2VsZWN0YWJsZSAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdG9nZ2xlKClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDbGljayA9ICh0b2dnbGUsIGlzU2hvd24pID0+IHtcbiAgICBjb25zdCB7IHNob3VsZENsaWNrVG9nZ2xlIH0gPSB0aGlzLnN0YXRlXG5cbiAgICBpZiAoIXNob3VsZENsaWNrVG9nZ2xlICYmICFpc1Nob3duKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2hvdWxkQ2xpY2tUb2dnbGU6IHRydWVcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5pc1NlbGVjdGFibGUgJiYgIXRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHRvZ2dsZSgpXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2hvdWxkQ2xpY2tUb2dnbGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpc0ZvY3VzZWQ6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3VsZENsaWNrVG9nZ2xlOiBmYWxzZSxcbiAgICAgIGlzRm9jdXNlZDogZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgdGhlbWUsXG4gICAgICBzaXplLFxuICAgICAgc2VsZWN0TWVudVByb3BzLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgIHRleHRQcm9wcyA9IHt9LFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgdGFyZ2V0V2lkdGgsIGlzRm9jdXNlZCB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgbGV0IGN1cnNvciA9ICdkZWZhdWx0J1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgY3Vyc29yID0gJ25vdC1hbGxvd2VkJ1xuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3RhYmxlKSB7XG4gICAgICBpZiAoaXNGb2N1c2VkKSB7XG4gICAgICAgIGN1cnNvciA9ICdwb2ludGVyJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gJ2RlZmF1bHQnXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9ICd0ZXh0J1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U2VsZWN0TWVudSB3aWR0aD17dGFyZ2V0V2lkdGh9IHsuLi5zZWxlY3RNZW51UHJvcHN9PlxuICAgICAgICB7KHsgdG9nZ2xlLCBnZXRSZWYsIGlzU2hvd24gfSkgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VGV4dFRhYmxlQ2VsbFxuICAgICAgICAgICAgICBpbm5lclJlZj17dGhpcy5vbk1haW5SZWYuYmluZChudWxsLCBnZXRSZWYpfVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrLmJpbmQobnVsbCwgdG9nZ2xlLCBpc1Nob3duKX1cbiAgICAgICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1cy5iaW5kKG51bGwsIHRvZ2dsZSwgaXNTaG93bil9XG4gICAgICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgICAgICBpc1NlbGVjdGFibGU9e2lzU2VsZWN0YWJsZSAmJiAhZGlzYWJsZWR9XG4gICAgICAgICAgICAgIHJpZ2h0Vmlldz17XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RhYmxlID8gPEljb24gaWNvbj1cImNhcmV0LWRvd25cIiBjb2xvcj1cIm11dGVkXCIgLz4gOiBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJpYS1oYXNwb3B1cFxuICAgICAgICAgICAgICBhcmlhLWV4cGFuZGVkPXtpc1Nob3dufVxuICAgICAgICAgICAgICBjdXJzb3I9e2lzU2hvd24gPyAncG9pbnRlcicgOiBjdXJzb3J9XG4gICAgICAgICAgICAgIHRleHRQcm9wcz17e1xuICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogZGlzYWJsZWQgfHwgKCFjaGlsZHJlbiAmJiBwbGFjZWhvbGRlcikgPyAwLjUgOiAxLFxuICAgICAgICAgICAgICAgIC4uLnRleHRQcm9wc1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bi5iaW5kKG51bGwsIHRvZ2dsZSwgaXNTaG93bil9XG4gICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s9e3RoaXMuaGFuZGxlRG91YmxlQ2xpY2suYmluZChudWxsLCB0b2dnbGUsIGlzU2hvd24pfVxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjaGlsZHJlbiA/IGNoaWxkcmVuIDogcGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICA8L1RleHRUYWJsZUNlbGw+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9TZWxlY3RNZW51PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoU2VsZWN0TWVudUNlbGwpXG4iXX0=