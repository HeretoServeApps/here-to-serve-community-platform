import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { Text } from '../../typography';
import { withTheme } from '../../theme';
import warning from '../../lib/warning';

var Tab =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(Tab, _PureComponent);

  function Tab() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Tab);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Tab)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (e) {
      if (typeof _this.props.onClick === 'function') {
        _this.props.onClick(e);
      }

      _this.props.onSelect();
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function (e) {
      if (e.key === 'Enter' || e.key === ' ') {
        _this.props.onSelect();

        e.preventDefault();
      }

      _this.props.onKeyPress(e);
    });

    return _this;
  }

  _createClass(Tab, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          theme = _this$props.theme,
          is = _this$props.is,
          height = _this$props.height,
          onSelect = _this$props.onSelect,
          isSelected = _this$props.isSelected,
          appearance = _this$props.appearance,
          disabled = _this$props.disabled,
          props = _objectWithoutProperties(_this$props, ["theme", "is", "height", "onSelect", "isSelected", "appearance", "disabled"]);

      if (process.env.NODE_ENV !== 'production') {
        warning(typeof this.props.onClick === 'function', '<Tab> expects `onSelect` prop, but you passed `onClick`.');
      }

      var textSize = theme.getTextSizeForControlHeight(height);
      var elementBasedProps;

      if (disabled) {
        elementBasedProps = {
          'aria-disabled': true
        };
      }

      if (is === 'a') {
        // Use aria-current when it's a link
        // https://tink.uk/using-the-aria-current-attribute/
        elementBasedProps = isSelected ? _objectSpread({}, elementBasedProps, {
          'aria-current': 'page'
        }) : {};
      } else {
        // Use a role="tablist" around the tabs
        // Also pass down a aria-controls="panelId"
        // https://www.stefanjudis.com/blog/aria-selected-and-when-to-use-it/
        elementBasedProps = _objectSpread({}, elementBasedProps, {
          'aria-selected': isSelected,
          role: 'tab'
        });
      }

      return React.createElement(Text, _extends({
        className: theme.getTabClassName(appearance),
        is: is,
        size: textSize,
        height: height
      }, Tab.styles, props, {
        onClick: this.handleClick,
        onKeyPress: this.handleKeyPress
      }, elementBasedProps));
    }
  }]);

  return Tab;
}(PureComponent);

Tab.displayName = "Tab";

_defineProperty(Tab, "propTypes", _objectSpread({}, Text.propTypes, {
  /**
   * Function triggered when tab is selected.
   */
  onSelect: PropTypes.func,

  /**
   * When true, the tab is selected.
   */
  isSelected: PropTypes.bool,

  /**
   * The appearance of the tab.
   * The default theme only comes with a default style.
   */
  appearance: PropTypes.string,

  /**
   * Theme provided by ThemeProvider.
   */
  theme: PropTypes.object.isRequired
}));

_defineProperty(Tab, "defaultProps", {
  onSelect: function onSelect() {},
  onKeyPress: function onKeyPress() {},
  is: 'span',
  height: 28,
  disabled: false
});

_defineProperty(Tab, "styles", {
  display: 'inline-flex',
  fontWeight: 500,
  paddingX: 8,
  marginX: 4,
  borderRadius: 3,
  lineHeight: '28px',
  alignItems: 'center',
  justifyContent: 'center',
  textDecoration: 'none',
  tabIndex: 0
});

export default withTheme(Tab);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJzL3NyYy9UYWIuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiVGV4dCIsIndpdGhUaGVtZSIsIndhcm5pbmciLCJUYWIiLCJlIiwicHJvcHMiLCJvbkNsaWNrIiwib25TZWxlY3QiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsIm9uS2V5UHJlc3MiLCJ0aGVtZSIsImlzIiwiaGVpZ2h0IiwiaXNTZWxlY3RlZCIsImFwcGVhcmFuY2UiLCJkaXNhYmxlZCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInRleHRTaXplIiwiZ2V0VGV4dFNpemVGb3JDb250cm9sSGVpZ2h0IiwiZWxlbWVudEJhc2VkUHJvcHMiLCJyb2xlIiwiZ2V0VGFiQ2xhc3NOYW1lIiwic3R5bGVzIiwiaGFuZGxlQ2xpY2siLCJoYW5kbGVLZXlQcmVzcyIsInByb3BUeXBlcyIsImZ1bmMiLCJib29sIiwic3RyaW5nIiwib2JqZWN0IiwiaXNSZXF1aXJlZCIsImRpc3BsYXkiLCJmb250V2VpZ2h0IiwicGFkZGluZ1giLCJtYXJnaW5YIiwiYm9yZGVyUmFkaXVzIiwibGluZUhlaWdodCIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsInRleHREZWNvcmF0aW9uIiwidGFiSW5kZXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsYUFBaEIsUUFBcUMsT0FBckM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixrQkFBckI7QUFDQSxTQUFTQyxTQUFULFFBQTBCLGFBQTFCO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixtQkFBcEI7O0lBRU1DLEc7Ozs7Ozs7Ozs7Ozs7Ozs7OztrRUFrRFUsVUFBQUMsQ0FBQyxFQUFJO0FBQ2pCLFVBQUksT0FBTyxNQUFLQyxLQUFMLENBQVdDLE9BQWxCLEtBQThCLFVBQWxDLEVBQThDO0FBQzVDLGNB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LEVBQUUsYUFESztBQUVkQyxFQUFBQSxVQUFVLEVBQUUsR0FGRTtBQUdkQyxFQUFBQSxRQUFRLEVBQUUsQ0FISTtBQUlkQyxFQUFBQSxPQUFPLEVBQUUsQ0FKSztBQUtkQyxFQUFBQSxZQUFZLEVBQUUsQ0FMQTtBQU1kQyxFQUFBQSxVQUFVLEVBQUUsTUFORTtBQU9kQyxFQUFBQSxVQUFVLEVBQUUsUUFQRTtBQVFkQyxFQUFBQSxjQUFjLEVBQUUsUUFSRjtBQVNkQyxFQUFBQSxjQUFjLEVBQUUsTUFURjtBQVVkQyxFQUFBQSxRQUFRLEVBQUU7QUFWSSxDOztBQThGbEIsZUFBZTFDLFNBQVMsQ0FBQ0UsR0FBRCxDQUF4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vLi4vdHlwb2dyYXBoeSdcbmltcG9ydCB7IHdpdGhUaGVtZSB9IGZyb20gJy4uLy4uL3RoZW1lJ1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vLi4vbGliL3dhcm5pbmcnXG5cbmNsYXNzIFRhYiBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBUZXh0IGNvbXBvbmVudCBhcyB0aGUgYmFzZS5cbiAgICAgKi9cbiAgICAuLi5UZXh0LnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRyaWdnZXJlZCB3aGVuIHRhYiBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSB0YWIgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwZWFyYW5jZSBvZiB0aGUgdGFiLlxuICAgICAqIFRoZSBkZWZhdWx0IHRoZW1lIG9ubHkgY29tZXMgd2l0aCBhIGRlZmF1bHQgc3R5bGUuXG4gICAgICovXG4gICAgYXBwZWFyYW5jZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFRoZW1lIHByb3ZpZGVkIGJ5IFRoZW1lUHJvdmlkZXIuXG4gICAgICovXG4gICAgdGhlbWU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBvblNlbGVjdDogKCkgPT4ge30sXG4gICAgb25LZXlQcmVzczogKCkgPT4ge30sXG4gICAgaXM6ICdzcGFuJyxcbiAgICBoZWlnaHQ6IDI4LFxuICAgIGRpc2FibGVkOiBmYWxzZVxuICB9XG5cbiAgc3RhdGljIHN0eWxlcyA9IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICBwYWRkaW5nWDogOCxcbiAgICBtYXJnaW5YOiA0LFxuICAgIGJvcmRlclJhZGl1czogMyxcbiAgICBsaW5lSGVpZ2h0OiAnMjhweCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgdGFiSW5kZXg6IDBcbiAgfVxuXG4gIGhhbmRsZUNsaWNrID0gZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucHJvcHMub25DbGljayhlKVxuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25TZWxlY3QoKVxuICB9XG5cbiAgaGFuZGxlS2V5UHJlc3MgPSBlID0+IHtcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXkgPT09ICcgJykge1xuICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdCgpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uS2V5UHJlc3MoZSlcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0aGVtZSxcbiAgICAgIGlzLFxuICAgICAgaGVpZ2h0LFxuICAgICAgb25TZWxlY3QsXG4gICAgICBpc1NlbGVjdGVkLFxuICAgICAgYXBwZWFyYW5jZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIHR5cGVvZiB0aGlzLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICc8VGFiPiBleHBlY3RzIGBvblNlbGVjdGAgcHJvcCwgYnV0IHlvdSBwYXNzZWQgYG9uQ2xpY2tgLidcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0U2l6ZSA9IHRoZW1lLmdldFRleHRTaXplRm9yQ29udHJvbEhlaWdodChoZWlnaHQpXG5cbiAgICBsZXQgZWxlbWVudEJhc2VkUHJvcHNcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIGVsZW1lbnRCYXNlZFByb3BzID0ge1xuICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXMgPT09ICdhJykge1xuICAgICAgLy8gVXNlIGFyaWEtY3VycmVudCB3aGVuIGl0J3MgYSBsaW5rXG4gICAgICAvLyBodHRwczovL3RpbmsudWsvdXNpbmctdGhlLWFyaWEtY3VycmVudC1hdHRyaWJ1dGUvXG4gICAgICBlbGVtZW50QmFzZWRQcm9wcyA9IGlzU2VsZWN0ZWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5lbGVtZW50QmFzZWRQcm9wcyxcbiAgICAgICAgICAgICdhcmlhLWN1cnJlbnQnOiAncGFnZSdcbiAgICAgICAgICB9XG4gICAgICAgIDoge31cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIGEgcm9sZT1cInRhYmxpc3RcIiBhcm91bmQgdGhlIHRhYnNcbiAgICAgIC8vIEFsc28gcGFzcyBkb3duIGEgYXJpYS1jb250cm9scz1cInBhbmVsSWRcIlxuICAgICAgLy8gaHR0cHM6Ly93d3cuc3RlZmFuanVkaXMuY29tL2Jsb2cvYXJpYS1zZWxlY3RlZC1hbmQtd2hlbi10by11c2UtaXQvXG4gICAgICBlbGVtZW50QmFzZWRQcm9wcyA9IHtcbiAgICAgICAgLi4uZWxlbWVudEJhc2VkUHJvcHMsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogaXNTZWxlY3RlZCxcbiAgICAgICAgcm9sZTogJ3RhYidcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRleHRcbiAgICAgICAgY2xhc3NOYW1lPXt0aGVtZS5nZXRUYWJDbGFzc05hbWUoYXBwZWFyYW5jZSl9XG4gICAgICAgIGlzPXtpc31cbiAgICAgICAgc2l6ZT17dGV4dFNpemV9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICB7Li4uVGFiLnN0eWxlc31cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuICAgICAgICBvbktleVByZXNzPXt0aGlzLmhhbmRsZUtleVByZXNzfVxuICAgICAgICB7Li4uZWxlbWVudEJhc2VkUHJvcHN9XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoVGFiKVxuIl19