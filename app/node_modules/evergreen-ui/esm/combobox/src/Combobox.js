import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Box, { dimensions, spacing, position, layout } from 'ui-box';
import { Autocomplete } from '../../autocomplete';
import { TextInput } from '../../text-input';
import { IconButton } from '../../buttons';
import deprecated from '../../lib/deprecated';

var Combobox =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(Combobox, _PureComponent);

  function Combobox(props, context) {
    var _this;

    _classCallCheck(this, Combobox);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Combobox).call(this, props, context));

    _defineProperty(_assertThisInitialized(_this), "handleStateChange", function (changes) {
      if (Object.prototype.hasOwnProperty.call(changes, 'isOpen')) {
        if (!changes.isOpen) {
          _this.setState({
            isOpenedByButton: false
          });
        }
      }
    });

    _this.state = {
      isOpenedByButton: false
    };
    return _this;
  }

  _createClass(Combobox, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          items = _this$props.items,
          selectedItem = _this$props.selectedItem,
          defaultSelectedItem = _this$props.defaultSelectedItem,
          initialSelectedItem = _this$props.initialSelectedItem,
          itemToString = _this$props.itemToString,
          width = _this$props.width,
          height = _this$props.height,
          onChange = _this$props.onChange,
          placeholder = _this$props.placeholder,
          inputProps = _this$props.inputProps,
          buttonProps = _this$props.buttonProps,
          openOnFocus = _this$props.openOnFocus,
          autocompleteProps = _this$props.autocompleteProps,
          isLoading = _this$props.isLoading,
          props = _objectWithoutProperties(_this$props, ["items", "selectedItem", "defaultSelectedItem", "initialSelectedItem", "itemToString", "width", "height", "onChange", "placeholder", "inputProps", "buttonProps", "openOnFocus", "autocompleteProps", "isLoading"]);

      var disabled = props.disabled || isLoading;
      return React.createElement(Autocomplete, _extends({
        items: items,
        selectedItem: selectedItem,
        initialSelectedItem: initialSelectedItem || defaultSelectedItem,
        itemToString: itemToString,
        onChange: onChange,
        onStateChange: this.handleStateChange,
        isFilterDisabled: this.state.isOpenedByButton
      }, autocompleteProps), function (_ref) {
        var getRef = _ref.getRef,
            isShown = _ref.isShown,
            openMenu = _ref.openMenu,
            inputValue = _ref.inputValue,
            getInputProps = _ref.getInputProps,
            getToggleButtonProps = _ref.getToggleButtonProps,
            clearSelection = _ref.clearSelection;
        return React.createElement(Box, _extends({
          innerRef: function innerRef(ref) {
            return getRef(ref);
          },
          display: "inline-flex",
          width: width
        }, props), React.createElement(TextInput, _extends({
          width: 0,
          flex: 1,
          height: height,
          value: inputValue,
          borderTopRightRadius: 0,
          borderBottomRightRadius: 0,
          disabled: disabled
        }, getInputProps(_objectSpread({}, inputProps, {
          placeholder: placeholder,
          onFocus: function onFocus() {
            if (openOnFocus) openMenu();
          },
          onChange: function onChange(e) {
            if (_this2.state.isOpenedByButton) {
              _this2.setState({
                isOpenedByButton: false
              });
            }

            if (e.target.value.trim() === '') {
              // Prevent the selected item from sticking around
              clearSelection();
            }
          }
        })))), React.createElement(IconButton, _extends({
          iconAim: "down",
          color: "muted",
          icon: isLoading ? '' : 'caret-down',
          appearance: "default",
          height: height,
          marginLeft: -1,
          paddingLeft: isLoading ? 12 : 0,
          paddingRight: 0,
          borderTopLeftRadius: 0,
          borderBottomLeftRadius: 0,
          disabled: disabled,
          isLoading: isLoading
        }, getToggleButtonProps(_objectSpread({}, buttonProps, {
          onClick: function onClick() {
            if (!isShown) {
              _this2.setState({
                isOpenedByButton: true
              });
            }
          }
        })))));
      });
    }
  }]);

  return Combobox;
}(PureComponent);

Combobox.displayName = "Combobox";

_defineProperty(Combobox, "propTypes", _objectSpread({}, dimensions.propTypes, {}, spacing.propTypes, {}, position.propTypes, {}, layout.propTypes, {
  /**
   * The options to show in the menu.
   */
  items: PropTypes.array.isRequired,

  /**
   * The selected item when controlled.
   */
  selectedItem: PropTypes.any,

  /**
   * Function called when value changes.
   */
  onChange: PropTypes.func,

  /**
   * When true, open the autocomplete on focus.
   */
  openOnFocus: PropTypes.bool,

  /**
   * Default selected item when uncontrolled.
   */
  initialSelectedItem: PropTypes.any,

  /**
   * Default selected item when uncontrolled (deprecated)
   */
  defaultSelectedItem: deprecated(PropTypes.any, 'Use "initialSelectedItem" instead.'),

  /**
   * The placeholder text when there is no value present.
   */
  placeholder: PropTypes.string,

  /**
   * In case the array of items is not an array of strings,
   * this function is used on each item to return the string that will be shown on the filter
   */
  itemToString: PropTypes.func,

  /**
   * Properties forwarded to the input. Use with caution.
   */
  inputProps: PropTypes.object,

  /**
   * Properties forwarded to the button. Use with caution.
   */
  buttonProps: PropTypes.object,

  /**
   * Properties forwarded to the autocomplete component. Use with caution.
   */
  autocompleteProps: PropTypes.object,

  /**
   * Makes the input element disabled.
   */
  disabled: PropTypes.bool,

  /**
   * When true, show a loading spinner. This also disables the button.
   */
  isLoading: PropTypes.bool
}));

_defineProperty(Combobox, "defaultProps", {
  width: 240,
  openOnFocus: false,
  disabled: false,
  isLoading: false
});

export { Combobox as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21ib2JveC9zcmMvQ29tYm9ib3guanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiQm94IiwiZGltZW5zaW9ucyIsInNwYWNpbmciLCJwb3NpdGlvbiIsImxheW91dCIsIkF1dG9jb21wbGV0ZSIsIlRleHRJbnB1dCIsIkljb25CdXR0b24iLCJkZXByZWNhdGVkIiwiQ29tYm9ib3giLCJwcm9wcyIsImNvbnRleHQiLCJjaGFuZ2VzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaXNPcGVuIiwic2V0U3RhdGUiLCJpc09wZW5lZEJ5QnV0dG9uIiwic3RhdGUiLCJpdGVtcyIsInNlbGVjdGVkSXRlbSIsImRlZmF1bHRTZWxlY3RlZEl0ZW0iLCJpbml0aWFsU2VsZWN0ZWRJdGVtIiwiaXRlbVRvU3RyaW5nIiwid2lkdGgiLCJoZWlnaHQiLCJvbkNoYW5nZSIsInBsYWNlaG9sZGVyIiwiaW5wdXRQcm9wcyIsImJ1dHRvblByb3BzIiwib3Blbk9uRm9jdXMiLCJhdXRvY29tcGxldGVQcm9wcyIsImlzTG9hZGluZyIsImRpc2FibGVkIiwiaGFuZGxlU3RhdGVDaGFuZ2UiLCJnZXRSZWYiLCJpc1Nob3duIiwib3Blbk1lbnUiLCJpbnB1dFZhbHVlIiwiZ2V0SW5wdXRQcm9wcyIsImdldFRvZ2dsZUJ1dHRvblByb3BzIiwiY2xlYXJTZWxlY3Rpb24iLCJyZWYiLCJvbkZvY3VzIiwiZSIsInRhcmdldCIsInZhbHVlIiwidHJpbSIsIm9uQ2xpY2siLCJwcm9wVHlwZXMiLCJhcnJheSIsImlzUmVxdWlyZWQiLCJhbnkiLCJmdW5jIiwiYm9vbCIsInN0cmluZyIsIm9iamVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxhQUFoQixRQUFxQyxPQUFyQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxPQUFP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QUFFcEMsU0FBUyxDQUFDeUQsSTs7QUFFcEI7OztBQUdBdEIsRUFBQUEsU0FBUyxFQUFFbkMsU0FBUyxDQUFDeUQ7OztnQkE3RUovQyxRLGtCQWdGRztBQUNwQmlCLEVBQUFBLEtBQUssRUFBRSxHQURhO0FBRXBCTSxFQUFBQSxXQUFXLEVBQUUsS0FGTztBQUdwQkcsRUFBQUEsUUFBUSxFQUFFLEtBSFU7QUFJcEJELEVBQUFBLFNBQVMsRUFBRTtBQUpTLEM7O1NBaEZIekIsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgQm94LCB7IGRpbWVuc2lvbnMsIHNwYWNpbmcsIHBvc2l0aW9uLCBsYXlvdXQgfSBmcm9tICd1aS1ib3gnXG5pbXBvcnQgeyBBdXRvY29tcGxldGUgfSBmcm9tICcuLi8uLi9hdXRvY29tcGxldGUnXG5pbXBvcnQgeyBUZXh0SW5wdXQgfSBmcm9tICcuLi8uLi90ZXh0LWlucHV0J1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiB9IGZyb20gJy4uLy4uL2J1dHRvbnMnXG5pbXBvcnQgZGVwcmVjYXRlZCBmcm9tICcuLi8uLi9saWIvZGVwcmVjYXRlZCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tYm9ib3ggZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHNvbWUgQVBJcyBmcm9tIHVpLWJveC5cbiAgICAgKi9cbiAgICAuLi5kaW1lbnNpb25zLnByb3BUeXBlcyxcbiAgICAuLi5zcGFjaW5nLnByb3BUeXBlcyxcbiAgICAuLi5wb3NpdGlvbi5wcm9wVHlwZXMsXG4gICAgLi4ubGF5b3V0LnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zIHRvIHNob3cgaW4gdGhlIG1lbnUuXG4gICAgICovXG4gICAgaXRlbXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGVkIGl0ZW0gd2hlbiBjb250cm9sbGVkLlxuICAgICAqL1xuICAgIHNlbGVjdGVkSXRlbTogUHJvcFR5cGVzLmFueSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHZhbHVlIGNoYW5nZXMuXG4gICAgICovXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvcGVuIHRoZSBhdXRvY29tcGxldGUgb24gZm9jdXMuXG4gICAgICovXG4gICAgb3Blbk9uRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzZWxlY3RlZCBpdGVtIHdoZW4gdW5jb250cm9sbGVkLlxuICAgICAqL1xuICAgIGluaXRpYWxTZWxlY3RlZEl0ZW06IFByb3BUeXBlcy5hbnksXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHNlbGVjdGVkIGl0ZW0gd2hlbiB1bmNvbnRyb2xsZWQgKGRlcHJlY2F0ZWQpXG4gICAgICovXG4gICAgZGVmYXVsdFNlbGVjdGVkSXRlbTogZGVwcmVjYXRlZChcbiAgICAgIFByb3BUeXBlcy5hbnksXG4gICAgICAnVXNlIFwiaW5pdGlhbFNlbGVjdGVkSXRlbVwiIGluc3RlYWQuJ1xuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGxhY2Vob2xkZXIgdGV4dCB3aGVuIHRoZXJlIGlzIG5vIHZhbHVlIHByZXNlbnQuXG4gICAgICovXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHRoZSBhcnJheSBvZiBpdGVtcyBpcyBub3QgYW4gYXJyYXkgb2Ygc3RyaW5ncyxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb24gZWFjaCBpdGVtIHRvIHJldHVybiB0aGUgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBvbiB0aGUgZmlsdGVyXG4gICAgICovXG4gICAgaXRlbVRvU3RyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgZm9yd2FyZGVkIHRvIHRoZSBpbnB1dC4gVXNlIHdpdGggY2F1dGlvbi5cbiAgICAgKi9cbiAgICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBmb3J3YXJkZWQgdG8gdGhlIGJ1dHRvbi4gVXNlIHdpdGggY2F1dGlvbi5cbiAgICAgKi9cbiAgICBidXR0b25Qcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgZm9yd2FyZGVkIHRvIHRoZSBhdXRvY29tcGxldGUgY29tcG9uZW50LiBVc2Ugd2l0aCBjYXV0aW9uLlxuICAgICAqL1xuICAgIGF1dG9jb21wbGV0ZVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIGlucHV0IGVsZW1lbnQgZGlzYWJsZWQuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBzaG93IGEgbG9hZGluZyBzcGlubmVyLiBUaGlzIGFsc28gZGlzYWJsZXMgdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBpc0xvYWRpbmc6IFByb3BUeXBlcy5ib29sXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIHdpZHRoOiAyNDAsXG4gICAgb3Blbk9uRm9jdXM6IGZhbHNlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBpc0xvYWRpbmc6IGZhbHNlXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc09wZW5lZEJ5QnV0dG9uOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVN0YXRlQ2hhbmdlID0gY2hhbmdlcyA9PiB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGFuZ2VzLCAnaXNPcGVuJykpIHtcbiAgICAgIGlmICghY2hhbmdlcy5pc09wZW4pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbmVkQnlCdXR0b246IGZhbHNlIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc2VsZWN0ZWRJdGVtLFxuICAgICAgZGVmYXVsdFNlbGVjdGVkSXRlbSwgLy8gRGVwcmVjYXRlZFxuICAgICAgaW5pdGlhbFNlbGVjdGVkSXRlbSxcbiAgICAgIGl0ZW1Ub1N0cmluZyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgb25DaGFuZ2UsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGlucHV0UHJvcHMsXG4gICAgICBidXR0b25Qcm9wcyxcbiAgICAgIG9wZW5PbkZvY3VzLFxuICAgICAgYXV0b2NvbXBsZXRlUHJvcHMsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkIHx8IGlzTG9hZGluZ1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxBdXRvY29tcGxldGVcbiAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICBzZWxlY3RlZEl0ZW09e3NlbGVjdGVkSXRlbX1cbiAgICAgICAgaW5pdGlhbFNlbGVjdGVkSXRlbT17aW5pdGlhbFNlbGVjdGVkSXRlbSB8fCBkZWZhdWx0U2VsZWN0ZWRJdGVtfVxuICAgICAgICBpdGVtVG9TdHJpbmc9e2l0ZW1Ub1N0cmluZ31cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICBvblN0YXRlQ2hhbmdlPXt0aGlzLmhhbmRsZVN0YXRlQ2hhbmdlfVxuICAgICAgICBpc0ZpbHRlckRpc2FibGVkPXt0aGlzLnN0YXRlLmlzT3BlbmVkQnlCdXR0b259XG4gICAgICAgIHsuLi5hdXRvY29tcGxldGVQcm9wc31cbiAgICAgID5cbiAgICAgICAgeyh7XG4gICAgICAgICAgZ2V0UmVmLFxuICAgICAgICAgIGlzU2hvd24sXG4gICAgICAgICAgb3Blbk1lbnUsXG4gICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICBnZXRJbnB1dFByb3BzLFxuICAgICAgICAgIGdldFRvZ2dsZUJ1dHRvblByb3BzLFxuICAgICAgICAgIGNsZWFyU2VsZWN0aW9uXG4gICAgICAgIH0pID0+IChcbiAgICAgICAgICA8Qm94XG4gICAgICAgICAgICBpbm5lclJlZj17cmVmID0+IGdldFJlZihyZWYpfVxuICAgICAgICAgICAgZGlzcGxheT1cImlubGluZS1mbGV4XCJcbiAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8VGV4dElucHV0XG4gICAgICAgICAgICAgIHdpZHRoPXswfVxuICAgICAgICAgICAgICBmbGV4PXsxfVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XG4gICAgICAgICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzPXswfVxuICAgICAgICAgICAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1cz17MH1cbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICB7Li4uZ2V0SW5wdXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgLi4uaW5wdXRQcm9wcyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAob3Blbk9uRm9jdXMpIG9wZW5NZW51KClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmlzT3BlbmVkQnlCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgaXNPcGVuZWRCeUJ1dHRvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgc2VsZWN0ZWQgaXRlbSBmcm9tIHN0aWNraW5nIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICBjbGVhclNlbGVjdGlvbigpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8SWNvbkJ1dHRvblxuICAgICAgICAgICAgICBpY29uQWltPVwiZG93blwiXG4gICAgICAgICAgICAgIGNvbG9yPVwibXV0ZWRcIlxuICAgICAgICAgICAgICBpY29uPXtpc0xvYWRpbmcgPyAnJyA6ICdjYXJldC1kb3duJ31cbiAgICAgICAgICAgICAgYXBwZWFyYW5jZT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgbWFyZ2luTGVmdD17LTF9XG4gICAgICAgICAgICAgIHBhZGRpbmdMZWZ0PXtpc0xvYWRpbmcgPyAxMiA6IDB9XG4gICAgICAgICAgICAgIHBhZGRpbmdSaWdodD17MH1cbiAgICAgICAgICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1cz17MH1cbiAgICAgICAgICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1cz17MH1cbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICBpc0xvYWRpbmc9e2lzTG9hZGluZ31cbiAgICAgICAgICAgICAgey4uLmdldFRvZ2dsZUJ1dHRvblByb3BzKHtcbiAgICAgICAgICAgICAgICAuLi5idXR0b25Qcm9wcyxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbmVkQnlCdXR0b246IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvQXV0b2NvbXBsZXRlPlxuICAgIClcbiAgfVxufVxuIl19